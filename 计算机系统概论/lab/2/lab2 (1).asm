;---------------------------------------------
	.ORIG	X3000
	AND	R0,R0,#0
	LEA	R6,TEMP    	;R6 AS A POINTER OF THE STACK
CLEAR	ADD	R6,R6,#-1	;CLEAR THE STACK
	LDR	R0,R6,#0
	BRz	CLEARF
	AND	R0,R0,#0
	STR	R0,R6,#0
	BR	CLEAR
CLEARF	AND	R0,R0,#0	;CLEAR FINISH,INITIALIZE R0
	ST	R0,SAVE		;SET THE FLAG TO 0(INITIAL VALUE)
	LEA	R6,TEMP    	;R6 AS THE POINTER
	LEA	R0,PROMPT	;LOAD PROMPT
	TRAP	X22		;OUTPUT PROMPT
	AND	R4,R4,#0	;
	ADD	R4,R4,#4	;R4 AS THE COUNTER OF ELEMENTS IN A NODE(4 IN TOTAL)
;---------------------------------------------
GETSTR	TRAP	X20		;INPUT
	TRAP	X21       	;ECHO ON THE SCREEN
	ADD	R3,R0,#-10 	;WHETHER IS ENTER OR NOT,IF NOT, CONTINUE
	BRz	DONE  		;FINISH INPUTTING
	JSR	PUSH		;PUSH DATA ON THE STACK
	BR	GETSTR		
;---------------------------------------------
DONE	LEA	R6,TEMP		;RESET R6 TO THE BASE OF THE STACK TO TRAVERSE IT(DIFFERENT FROM THE TYPICAL WAY)
	LDI	R1,ADDR		;START AT THE HEAD OF LINKEDLIST	
	BRz	FALOVER		;IF THERE IS NO VALID INPUT, JUMP TO FALOVER(MEANS FAILED OR NO ENTRY)
PTR1	ADD	R4,R4,#-1	;R4 SUBTRACT 1,MEANS AN ELEMENT OF A NODE HAS BEEN TRAVERSED. R4 IGNORE THE FIRST ELEMENT--POINTER TO NEXT NODE
	BRz	PAOVER		;IF R4 == 0,ALL ELEMENTS OF A NODE HAVE BEEN TRAVERSED,JUMP TO THE NEXT NODE
	ADD	R1,R1,#1	;R1 ,AS THE SECOND-DEGREE POINTER, ADD 1 TO ACCESS THE NEXT ELEMENT
	LEA	R6,TEMP		;RESET POINTER R6
	LDR	R2,R1,#0	;R2, AS THE FIRST-DEGREE POINTER, IS USED TO TRAVERSE EVERY CHARACTER IN AN ELEMENT 
PTR2	LDR	R3,R2,#0	;R3,STORE THE CHARACTER
	BRz	FOUND1		;IF FINDING '\0',WHICH MEANS THE STRING ELEMENT IS AT AN END,JUMP TO FOUND1(THE FOUND STRING IS A PART OF INPUT STRING) 
	NOT	R3,R3		
	ADD	R3,R3,#1
	JSR	POPB
	ADD	R5,R0,R3	;COMPARISION
	BRnp	PTR1		;A CHAR IS DIFFERENT FROM THE INPUT ONE, THEN JUMP BACK TO ACCESS THE NEXT ELEMENT
	ADD	R2,R2,#1	;R2 ADD 1 TO ACCESS THE NEXT CHAR
	BR	PTR2		;
PAOVER	ADD	R4,R4,#4	;HAVING TRAVERSED THE WHOLE NODE, RESET R4
	ADD	R1,R1,#-3	;RESET R1 TO THE FIRST ELEMENT--POINTER TO NEXT NODE
	LDR	R1,R1,#0	;POINT R1 TO THE NEXT NODE
	BRnp	PTR1		;IF NEXT NODE EXISTS,JUMP BACK;ELSE STOP TRAVERSING
FALOVER	LD	R0,SAVE		;LOAD THE STAUS CODE
	BRp	STO		;IF 1(SUCCESS),HALT WITHOUT PRINTING "NO ENTRY"
	LEA	R0, FAIL
	TRAP	X22		;IF FAIL, PRINT"NO ENTRY",THEN HALT
STO	TRAP	X25		;HALT			
;----------------------------------------------
PUSH	ADD	R6,R6,#-1	;PUSH FUNCTION
	STR	R0,R6,#0
	RET
;---------------------------------------------
POPB	LDR	R0,R6,#-1	; UNIQUE POP FUNCTION(POPB)
	ADD	R6,R6,#-1
	RET
;---------------------------------------------
FOUND1	ADD	R6,R6,#-1	;ALTHOUGH THE FOUND ONE IS A PART OF INPUT ONE, THEY MAY NOT BE INDENTICAL
	LDR	R5,R6,#0	;MAKE SURE THE INPUT ONE IS ALSO AT AN END
	BRnp	PTR1		;IF NOT, THEY ARE NOT INDENTICAL,JUMP BACK TO ACCESS THE NEXT ELEMENT
;----------------------------------------------
FOUND	AND	R0,R0,0		;PRINT THE ELEMENT OF A NODE ONE BY ONE
	ADD	R0,R0,#1
	ST	R0,SAVE		;SET THE STATUS 1£¬WHICH MEANS THERE IS ENTRY(ENTRIES)
	ADD 	R1,R1,R4
	ADD 	R1,R1,#-3	;R1-(4-R4)+1,RETURN TO THE FIRST ELEMENT
	LDR  	R0,R1,#0
	TRAP 	X22
	LD	R0,ASCII1
	TRAP	X21		;PRINT BLANK
	ADD 	R1,R1,#1
	LDR 	R0,R1,#0
	TRAP 	X22
	LD	R0,ASCII1
	TRAP	X21
	ADD 	R1,R1,#1
	LDR 	R0,R1,#0
	TRAP 	X22
	LD	R0,ASCII2
	TRAP	X21		;PRINT'\n'

	AND	R4,R4,#0	;RESET ALL TO ACCESS THE NEXT ELEMENT
	ADD	R4,R4,#4
	ADD	R1,R1,#-3
	LDR	R1,R1,#0
	BRnp	PTR1
	TRAP	X25		;HALT IF ALL THE NODES HAVE BEEN TRAVERSED	
;----------------------------------------------	
PROMPT	.STRINGZ "Type a name and press enter:"
MAX	.BLKW	#30		;STACK AREA
TEMP	.FILL	#0		
FAIL	.STRINGZ "No Entry"
TOP	.BLKW	1
;---------------------------------------------
ADDR	.FILL 	X4000
ASCII1	.FILL 	#32		;ASCII OF BLANK
ASCII2	.FILL 	#10		;ASCII OF '\n'
SAVE	.BLKW 	1		;STATUS CODE
	.END