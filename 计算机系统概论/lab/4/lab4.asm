	.ORIG 	x3000
	BR      GET 	        ;R6 AS THE STACK POINTER
BACK	LD 	R5, MARTIX	;R5 AS THE MARTIX POINTER,+-CLUMN MEANS JUMP ROW +-1 MEANS JUMP COLUMN
	LDI     R1, ROWS	;CACULATE THE NEGATIVE BOTTOM OF ARRAY
	BRz     STOP1           ;ROW=0,THE PATH MUST BE 0 AND THE WHOLE PROGRAM WILL BE AT AN END
	LDI     R2, COLUMNS
	BRz     STOP1           ;COLUMN = 0,THE PATH MUST BE 0 AND THE WHOLE PROGRAM WILL BE AT AN END
	LD 	R3, MARTIX
MULTPLY	ADD 	R3, R3, R2	;HERE USE R2 IS OK
	ADD 	R1, R1, #-1
	BRp 	MULTPLY
	NOT 	R3, R3
	ADD     R3, R3, #1 	; CALULATE THE NEGATIVE BOTTOM OF ARRAY
	ST 	R3, BOTTOM	

	AND     R3, R3, #0
	ST      R3, MAXLEN
	LD 	R3, MARTIX	;CACULATE THE NEGATIVE TOP OF ARRAY
	ADD 	R3, R3, #-1
	NOT 	R3, R3
	ADD 	R3, R3, #1
	ST 	R3, NTOP
	LEA     R7, TOTOV
	AND     R1, R1, #0
;----------------------------------RECURSION
ALL     ADD     R5, R5, R1	;START FROM A POINT (CONTROLED BY THE VALUE OF R1)
	LD      R3, BOTTOM	;
	ADD     R3, R3, R5	;
	BRzp    TOTOT		;IF R5 HAS OVER THE BOTTOM, STOP TRAVERSING AND FINISH THE PROGRAM
RECUR   ADD 	R6, R6, #-1	;THE START OF RECURSION FUNCTION
EAST	STR 	R7, R6, #0	;STORE RETURN ADDRESS
	ADD     R6, R6, #-1	;PUSH THE STACK
	STR     R5, R6, #0 	;STORE THE ADDRESS OF THIS POINT IN ARRAY
	ADD 	R5, R5, #1	;MOVE TO EAST
	LD 	R3, BOTTOM	;
	ADD     R3, R3, R5	;
	BRzp    SOUTH		;OVERFLOW OUT OF THE ARRAY, THEN JUMP TO NEXT DIRECTION

OVERFL  ST 	R1, SAVER1	;OTHER OVERFLOW CASES(OVERFLOW BUT JUST TO NEXT LINE)
	ST 	R2, SAVER2	
	ST      R4, SAVER4	;SAVE THE VALUE OF REGISTER THAT WILL BE USED SOON
	LD      R0, BOTTOM
	NOT 	R0, R0
	ADD 	R0, R0, #1
	LD 	R1, NTOP
	LDI     R4, COLUMNS
	NOT 	R4, R4
	ADD 	R4, R4, #1	;NEGATIVE COLUMN
LOOP1	ADD 	R0, R0, R4
	ADD 	R2, R0, R1	;IF ALL THE CASES HAS BEEN USED BUT FIND NO OVERFLOW, JUMP TO FINISH1
	BRnz 	FINISH1		
	NOT 	R0, R0		;TEST ALL THE POSIIBLE OVERFLOW CASES
	ADD 	R0, R0, #1
	ADD 	R2, R0, R5
	BRz     FINISH2		;IF ANY CASE EQUAL TO THE GIVEN ADDRESS, WHICH MEANS THERE IS OVERFLOW,JUMP TO FINISH2
	ADD     R0, R0, -1
	NOT     R0, R0
	BRnzp 	LOOP1
FINISH1	AND     R0, R0, #0	;R0 = 0, MEANS THAT THERE IS NO OVERFLOW
	BRnzp   FINISH
FINISH2 AND     R0, R0, #0
	ADD 	R0, R0, #1	;R0 = 1 ,MEANS THAT THERE IS OVERFLOW
FINISH  LD      R1, SAVER1
	LD      R2, SAVER2	;RELOAD THE FORMER VALUE INTO REGISTERS
	LD      R4, SAVER4	

	ADD 	R0, R0, #0
	BRp     SOUTH           ;OVERFLOW
	LDR 	R3, R5, #0	;READ THE HEIGHT OF NEXT POINT
	LDR     R4, R5, #-1	;READ THE HEIGHT OF THIS POINT
	NOT     R4, R4
	ADD     R4, R4, #1	
	ADD     R3, R4, R3
	BRzp    SOUTH		;IF NEXT POINT IS HIGHER(OR EQUAL), WHICH MEANS THIS WAY CAN'T GO THROUGH, JUMP TO NEXT DIRECTION
	JSR     RECUR           ;IF THIS WAY WORKS, CALL THE NEXT POINT

SOUTH   ADD     R5, R5, #-1	
	LDI     R4, COLUMNS      
	ADD     R5, R5, R4      ;NEXT ROW
	NOT     R4, R4
	ADD     R4, R4, #1
	LD      R3, BOTTOM
	ADD     R3, R3, R5
	BRzp    NORTH		;IF OVERFLOW, JUMP TO NEXT DIRECTION
	LDR     R3, R5, #0
	AND     R0, R0, #0
	ADD     R0, R5, R4
	LDR     R4, R0, #0
	NOT     R4, R4
	ADD     R4, R4, #1
	ADD     R3, R4, R3
	BRzp    NORTH		;IF NEXT POINT IS HIGHER(OR EQUAL),  JUMP TO NEXT DIRECTION
	JSR     RECUR           ;CALL THE NAXT POINT

NORTH	LDI     R4, COLUMNS
	NOT     R4, R4
	ADD     R4, R4, #1
	ADD     R5, R5, R4
	ADD     R5, R5, R4      ;NEXT ROW
	LD      R3, NTOP
	ADD     R3, R3, R5
	BRnz    WEST            ;IF OVERFLOW, JUMP TO NEXT DIRECTION		
	LDI     R4, COLUMNS
	AND     R0, R0, #0
	LDR     R3, R5, #0
	ADD     R0, R5, R4 
	LDR     R4, R0, #0
	NOT     R4, R4		
	ADD     R4, R4, #1
	ADD     R3, R4, R3
	BRzp    WEST		;IF NEXT POINT IS HIGHER(OR EQUAL),  JUMP TO NEXT DIRECTION
	JSR     RECUR

WEST    LDI     R4, COLUMNS
	ADD 	R5, R5, R4
	ADD 	R5, R5, #-1
	LD      R3,NTOP
	ADD     R3, R3, R5
	BRnz 	FINAL

UNDERFL ST 	R1, SAVER1
	ST 	R2, SAVER2
	ST      R4, SAVER4
	LD      R0, MARTIX
	ADD     R0, R0, #-1     ;TEST OVERFLOW(THE SAME AS EAST)
	LD 	R1, BOTTOM
	LDI     R4, COLUMNS
LOOP2	ADD 	R0, R0, R4
	ADD 	R2, R0, R1
	BRzp 	FINISH3
	NOT 	R0, R0
	ADD 	R0, R0, #1
	ADD 	R2, R0, R5
	BRz     FINISH4
	NOT 	R0, R0
	ADD 	R0, R0, #1	
	BRnzp 	LOOP2		
FINISH3	AND     R0, R0, #0      ;NOT OVERFLOW
	BRnzp   FINISH0
FINISH4 AND     R0, R0, #0
	ADD 	R0, R0, #1
FINISH0 LD      R1, SAVER1
	LD      R2, SAVER2
	LD      R4, SAVER4	

	ADD     R0, R0, #0
	BRp     FINAL		;OVERFLOW, JUMP TO FINAL(NO MORE DIRECTION CAN GO TO)
	LDR 	R3, R5, #0	;READ THE HEIGHT OF  ODD POINT
	LDR     R4, R5, #1
	NOT     R4, R4
	ADD     R4, R4, #1
	ADD     R3, R4, R3
	BRzp    FINAL 		;IF NEXT POINT IS HIGHER(OR EQUAL),  JUMP TO FINAL(NO MORE DIRECTION CAN GO TO)
	JSR     RECUR           ;CALL THE NEXT POINT

FINAL   BR      FETCH		;LD R3 WITH BASE
FEED	ADD     R4, R6, #0	
	NOT     R4, R4
	ADD     R4, R4, #1
	ADD     R3, R3, R4      ;CALCULATE 2*(LENGTH OF PATH) BY R6 SUBTRACT BASE
	LD      R4, LEN
	NOT     R4, R4
	ADD     R4, R4, #1
	ADD     R4, R4, R3
	BRnz    OVER            ;IF FORMER LEN IS BIGGER THAN NEW ONE, THE VALUE WON'T BE CHANGED
	ST      R3, LEN         ;ELSE, THE VLUE WILL BE CHANGED
OVER    LDR     R5, R6, #0      ;POP THE ADDRESS OF THE POINT AT UPPER LEVEL OF RECURSION
	ADD     R6, R6, #1
	LDR     R7, R6, #0	;POP THE RETURN ADDRESS TO RETURN TO UPPER LEVEL OF RECURSION
	ADD     R6, R6, #1 
	RET                     ;RETURN

TOTOV   LD      R3, LEN         ;THE RECURSION IS OVER AND WE HAVE GOT THE LONGEST PATH OF A CERTAIN POINT
	LD      R4, MAXLEN      ;WE SHOULD COMPARE IT TO THE "LONGEST PATH" BEFORE(MAY BE ANOTHER POINT'S)
	NOT     R4, R4
	ADD     R4, R4, #1
	ADD     R4, R3, R4
	BRnz    OW              ;IF THE OLD LENGTH IS BIGGER, THE VALUE WON'T BE CHANGED
	ST      R3, MAXLEN      ;ELSE, THE VALUE WILL BE REPLACED WITH BIGGER ONE
OW      AND     R3, R3, #0
	ST      R3, LEN
	ADD     R1, R1, #1      ;R1 PLUS 1 TO ACCESS THE NEXT POINT
	LD      R5,MARTIX       ;RESET R5
	LEA     R7, TOTOV	;RESET R7
	BR      ALL             ;TURN BACK TO TEST THE NEXT POINT

TOTOT   LD      R0, MAXLEN	;LOAD RESULTS
	AND     R2, R2, #0      
cir	ADD     R0, R0, #-1
	ADD     R2, R2, #1
	ADD     R4, R2, #0
	NOT     R4, R4          ;MAXLEN = MANLEN / 2
	ADD     R4, R4, #1
	ADD     R4, R4, R0
	BRnp    cir
	ST      R0, MAXLEN      ;STORE THE FINAL RESULT IN MAXLEN
	LD      R2, MAXLEN      ;LOAD THE FINAL RESULT IN R2
	BR      STOP2           ;JUMP TO HALT
STOP1	AND     R2, R2, #0      ;EITHER ROW OR COLUMN IS 0, R2 = 0
STOP2	HALT

;-----------------------------------------------------some costants

ROWS	.FILL   X3200
COLUMNS	.FILL   X3201
MARTIX	.FILL   X3202
SAVE 	.BLKW 	1
NTOP	.BLKW   1		;ACTUALLY THE NAGATIVE TOP
BOTTOM	.BLKW   1		;ACTUALLY THE NAGATIVE BOTTOM   
SAVER1	.BLKW   1
SAVER2	.BLKW   1
SAVER4	.BLKW   1 
SAVER7	.BLKW   1
LEN	.BLKW   1
MAXLEN	.BLKW   1
JUM     .FILL   #200
GET     LEA     R6, BASE
	BR      BACK 
FETCH   LEA     R3, BASE
	BR      FEED
TOP	.BLKW 	#200	
BASE	.FILL 	#0		;base of the recursive stack

.END
;PROGRAM: "SKIING"
;Regisiter that should avoided using or must be saved and preserved: 
;--R6:Used as the pointer of recursion stack
;--R7:JSR and trap need it
;--R0:dont use except for I/O operation
;--R2:CAN'T USE BUT TO STORE THE OUTPUT!!
;ATTENTION: EQUAL CAN'T GO THROUGH TO!
;--------------------------------------------------------------body
;-----------------------------INITIALIZATION